#!/bin/bash

# Display help information
display_help() {
    echo "Usage: $0 <SOLIDITY_SOURCE_FILE_PATH> <SOLCJS_INPUT_JSON_TEMPLATE_FILE_PATH> <BYTECODE_HEADER_TEMPLATE_FILE_PATH>"
    echo "This script takes in three required file paths as arguments and outputs the generated bytecode header file to standard output."
}

# Check for help option
if [ "$1" = "-h" ] || [ "$1" = "--help" ]; then
    display_help
    exit 0
fi

# Check if the number of arguments is correct
if [ "$#" -ne 3 ]; then
    echo -e "Error: Three file paths are required.\n"
    display_help
    exit 1
fi

SOLIDITY_SOURCE_FILE_PATH="$1"
SOLCJS_INPUT_JSON_TEMPLATE_FILE_PATH="$2"
BYTECODE_HEADER_TEMPLATE_FILE_PATH="$3"

set -o pipefail

# Some note to the solidity compiling process:
# 1 Ubuntu RPM for solc is outdated. Therefore we choose solcjs so that we can easily keep the compiler up to date.
# 2 solcjs will start to generate PUSH0 after 0.8.20. We do not support this yet, so we have to specify EVM versions using standard-json inputs.
# 3 solcjs --starndard-json has some bugs (https://github.com/ethereum/solc-js/issues/460) so we can only use "content" as input.
# 4 To copy the source code into the json file, we have to escape \\ \" \t \n. (Ignore \b \r \f as we shouldn't have them in sol file)
tmpfile=$(mktemp)
cat "$SOLIDITY_SOURCE_FILE_PATH" \
| awk -v token="__CONTRACT_CONTENT" '
    BEGIN {
        RS = "\0"   # Set record separator to null to read the whole input
    }
    function escape(str) {
        gsub(/\\/,"\\\\",str)         # Escape backslashes first
        gsub(/\n/,"\\n",str)          # Escape newlines
        gsub(/\t/,"\\t",str)          # Escape tabs
        gsub(/"/,"\\\"",str)          # Escape double quotes
        gsub(/&/,"\\\\&",str)         # Escape ampersands to not confuse gsub
        return str
    }
    {
        template = $0
        getline new_content < "/dev/stdin"
        new_content = escape(new_content)
        gsub(token, new_content, template)
        print template
    }
    ' "$SOLCJS_INPUT_JSON_TEMPLATE_FILE_PATH" \
| solcjs -p --standard-json > $tmpfile `# Compile Solidity code`
cat $tmpfile \
| grep -v ">>>" `# Remove any additional messages solcjs prints` \
| jq --stream 'try inputs' `# This and the next line are to work around the fact that solcjs outputs an incomplete JSON` \
| jq -n 'reduce inputs as $i ({}; if ($i | has(1)) then setpath($i[0]; $i[1]) else . end)' \
| jq -j '.contracts[][].evm.bytecode.object' `# Get the hex encoding of the bytecode (assumes only one source)` \
| xxd -r -p \
| xxd -i \
| awk -v token="__CONTRACT_BYTECODE" '
    BEGIN {
        RS = "\0"   # Set record separator to null to read the whole input
    }
    {
        while (index($0, token) > 0) {
            pre = substr($0, 1, index($0, token) - 1)
            post = substr($0, index($0, token) + length(token))
            getline new_content < "/dev/stdin"
            $0 = pre new_content post
        }
        print
    }
    ' "$BYTECODE_HEADER_TEMPLATE_FILE_PATH"
    rm -f $tmpfile